OpenCV 中有一些预先训练好的级联分类器，可用于检测人脸、脸部特征、人类和其他物体。这些级联分类器以XML 文件的形式存储在源文件的 data 目录下。例如：
C:\opencv\sources\data\haarcascades

### 用 Haar 级联实现人脸检测

经过预先训练的模型可以直接使用。只需用相应的XML文件，创建 cv::CascadeClassifier 类的实例：
```c++
cv::CascadeClassifier faceCascade;
    if (!faceCascade.load("haarcascade_frontalface_default.xml")) {
        std::cout << "Error when loading the face cascade classfier!" << std::endl;
        return -1;
    }
```
<br>

然后用 Haar 特征检测人脸，代码为：
```
faceCascade.detectMultiScale(picture, // 输入图像 
		detections, // 检测结果
		1.1,        // 缩小比例
		3,          // 所需近邻数量
		0,          // 标志位（不用）
		cv::Size(48, 48),    // 检测对象的最小尺寸
		cv::Size(128, 128)); // 检测对象的最大尺寸
    
// 在图像上画出检测结果
for (int i = 0; i < detections.size(); i++)
  cv::rectangle(picture, detections[i], cv::Scalar(255, 255, 255), 2);
```
<br>

### 级联增强分类器

**Haar 特征**

通常认为像素级别的建模方式过于低级，难以鲁棒地表示每个类别的内在特性。选用的模型最好能在多种尺度下描述图像的独特图案。
<br>

Haar 特征定义了包含像素的小型矩形区域，然后用减法运算比较这些矩形。常用的配置有三种，即二矩形特征、三矩形特征和四矩形特征。

![haar](https://github.com/sumpig/OpenCV/blob/master/%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B/pictures/haar.png)

这些特征可以为任意大小，可以应用于图像上的任何区域。
<br>

构建Haar 模型的步骤是，先选取一定数量的特定类型、尺寸和位置的Haar 特征，然后将它们应用于图像。手动挑选显然是很困难的。因此，我们要采用机器学习方法，为特定的类别选择最适合的特征。
<br>

**构建增强型级联特征**

为了训练针对特定类别的增强型级联分类器，OpenCV 提供了一个软件工具，可以完成全部必需的操作。安装该软件后，在对应的bin 目录下有两个可执行文件，即opencv_createsamples.exe 和 opencv_traincascade.exe。要确保系统的PATH 指向这个目录，以便能在任何位置启动这些工具。
<br>

训练分类器的第一件事就是选取样本。。下面是一个简单的例子，要训练一个能识别停止路标的分类器。选取的一些正样本如下图所示。

![stop](https://github.com/sumpig/OpenCV/blob/master/%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B/pictures/stop.png)

正样本清单必须存储在一个文本文件中，这里的文件名为stop.txt。文件中包含图像文件名和矩形的坐标：

stop00.png 1 0 0 64 64<br>
stop01.png 1 0 0 64 64<br>
stop02.png 1 0 0 64 64<br>
stop03.png 1 0 0 64 64<br>
stop04.png 1 0 0 64 64<br>
stop05.png 1 0 0 64 64<br>
stop06.png 1 0 0 64 64<br>
stop07.png 1 0 0 64 64<br>

图像文件名后的第一个数字表示图像中正样本的数量，紧接着的两个数字表示包含正样本的矩形的左上角坐标，然后是矩形的宽度和高度。

生成这个文件后，就可以调用提取工具生成正样本文件。
```
opencv_createsamples -info stop.txt -vec stop.vec -w 24 -h 24 -num 8
```
<br>

上述操作的输出文件是stop.vec，文件存储了文本文件中指定的全部正样本。注意，这里的样本尺寸变小了，从原始尺寸(64×64)变为了(24×24)。提取工具会根据指定的尺寸缩放样本。通常情况下，Haar 特征更适合使用较小的模板，但也要看具体的情况。

负样本就是背景图像，即没有包含所需类别的实例（在本例中就是没有停止路标）。但是这些图像应该包含分类器所需的各种内容。没有关于需要多少负样本图像的要求，训练时会从中随机提取。我们用下面的图片作为背景图像。

![negative](https://github.com/sumpig/OpenCV/blob/master/%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B/pictures/negative.png)

准备好正样本和负样本后，就可以开始训练级联分类器了。调用方法为：

```
opencv_traincascade -data classifier -vec stop.vec
		-bg neg.txt -numPos 9 -numNeg 20
		-numStages 20 -minHitRate 0.95
		-maxFalseAlarmRate 0.5 -w 24 -h 24
```
<br>

在运行过程中，每执行完一个阶段都会输出性能报告。其中需要特别关注的是当前命中率（hit rate，HR）；这个值表示当前被接受的正样本的百分比（即当前被识别为正实例，又称真正样本），这个数值越接近1.0 越好。此外还会有当前虚警率（false alarm rate，FA），它表示被误认为正实例的负样本（又称假正样本），这个数值越接近0.0 越好。每个阶段的每个特征都会显示这两个数值。

分类器的训练结果存储在一个XML 文件里。到这一步，分类器就已经可以使用了！它的用法非常简单，首先装载对应的 XML 文件，构建分类器:
```c++
cv::CascadeClassifier cascade;
    if (!cascade.load("stopSamples/classifier/cascade.xml")) {  // 对应的 XML 文件
        std::cout << "Error when loading the cascade classfier!" << std::endl; 
        return -1; 
    }

    // predict the label of this image
    std::vector<cv::Rect> detections;

    cascade.detectMultiScale(inputImage, // input image 
                             detections, // detection results
                             1.1,        // scale reduction factor
                             1,          // number of required neighbor detections
                             0,          // flags (not used)
                             cv::Size(48, 48),    // minimum object size to be detected
                             cv::Size(128, 128)); // maximum object size to be detected

    std::cout << "detections= " << detections.size() << std::endl;
    for (int i = 0; i < detections.size(); i++)
        cv::rectangle(inputImage, detections[i], cv::Scalar(255, 255, 255), 2);

    cv::imshow("Stop sign detection", inputImage);
```
<br>

用一幅图像测试这个分类器，得到如下结果。

![detection](https://github.com/sumpig/OpenCV/blob/master/%E5%AE%9E%E7%94%A8%E6%A1%88%E4%BE%8B/pictures/detection.png)
